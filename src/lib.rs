#[inline]
fn interpolate(a: f64, b: f64, v: [f64; 3], w: [f64; 3]) -> [f64; 3] {
    let x = a / (a - b);
    [(1. - x) * v[0] + x * w[0], (1. - x) * v[1] + x * w[1], (1. - x) * v[2] + x * w[2]]
}

fn tetrahedron(u: [f64; 4],
               v: [[f64; 3]; 4],
               verts: &mut Vec<[f64; 3]>,
               faces: &mut Vec<[u32; 3]>) {
    let u0 = u[0];
    let u1 = u[1];
    let u2 = u[2];
    let u3 = u[3];

    let v0 = v[0];
    let v1 = v[1];
    let v2 = v[2];
    let v3 = v[3];

    let tiny = 1e-15;

    // START GENERATED: generated by `scripts/tetrahedron_cuts.py`
    if u0 >= 0. {
        let u0 = u0 + tiny;
        if u1 >= 0. {
            let u1 = u1 + tiny;
            if u2 >= 0. {
                let u2 = u2 + tiny;
                if u3 >= 0. {
                } else {
                    let i = verts.len() as u32;
                    verts.push(interpolate(u3, u0, v3, v0));
                    verts.push(interpolate(u3, u1, v3, v1));
                    verts.push(interpolate(u3, u2, v3, v2));
                    faces.push([i, i + 1, i + 2]);
                }
            } else {
                if u3 >= 0. {
                    let i = verts.len() as u32;
                    verts.push(interpolate(u2, u0, v2, v0));
                    verts.push(interpolate(u2, u1, v2, v1));
                    verts.push(interpolate(u2, u3, v2, v3));
                    faces.push([i, i + 1, i + 2]);
                } else {
                    let i = verts.len() as u32;
                    verts.push(interpolate(u2, u0, v2, v0));
                    verts.push(interpolate(u2, u1, v2, v1));
                    verts.push(interpolate(u3, u0, v3, v0));
                    verts.push(interpolate(u3, u1, v3, v1));
                    faces.push([i, i + 1, i + 2]);
                    faces.push([i + 2, i + 1, i + 3]);
                }
            }
        } else {
            if u2 >= 0. {
                let u2 = u2 + tiny;
                if u3 >= 0. {
                    let i = verts.len() as u32;
                    verts.push(interpolate(u1, u0, v1, v0));
                    verts.push(interpolate(u1, u2, v1, v2));
                    verts.push(interpolate(u1, u3, v1, v3));
                    faces.push([i, i + 1, i + 2]);
                } else {
                    let i = verts.len() as u32;
                    verts.push(interpolate(u1, u0, v1, v0));
                    verts.push(interpolate(u1, u2, v1, v2));
                    verts.push(interpolate(u3, u0, v3, v0));
                    verts.push(interpolate(u3, u2, v3, v2));
                    faces.push([i, i + 1, i + 2]);
                    faces.push([i + 2, i + 1, i + 3]);
                }
            } else {
                if u3 >= 0. {
                    let i = verts.len() as u32;
                    verts.push(interpolate(u1, u0, v1, v0));
                    verts.push(interpolate(u1, u3, v1, v3));
                    verts.push(interpolate(u2, u0, v2, v0));
                    verts.push(interpolate(u2, u3, v2, v3));
                    faces.push([i, i + 1, i + 2]);
                    faces.push([i + 2, i + 1, i + 3]);
                } else {
                    let i = verts.len() as u32;
                    verts.push(interpolate(u1, u0, v1, v0));
                    verts.push(interpolate(u2, u0, v2, v0));
                    verts.push(interpolate(u3, u0, v3, v0));
                    faces.push([i, i + 1, i + 2]);
                }
            }
        }
    } else {
        if u1 >= 0. {
            let u1 = u1 + tiny;
            if u2 >= 0. {
                let u2 = u2 + tiny;
                if u3 >= 0. {
                    let i = verts.len() as u32;
                    verts.push(interpolate(u0, u1, v0, v1));
                    verts.push(interpolate(u0, u2, v0, v2));
                    verts.push(interpolate(u0, u3, v0, v3));
                    faces.push([i, i + 1, i + 2]);
                } else {
                    let i = verts.len() as u32;
                    verts.push(interpolate(u0, u1, v0, v1));
                    verts.push(interpolate(u0, u2, v0, v2));
                    verts.push(interpolate(u3, u1, v3, v1));
                    verts.push(interpolate(u3, u2, v3, v2));
                    faces.push([i, i + 1, i + 2]);
                    faces.push([i + 2, i + 1, i + 3]);
                }
            } else {
                if u3 >= 0. {
                    let i = verts.len() as u32;
                    verts.push(interpolate(u0, u1, v0, v1));
                    verts.push(interpolate(u0, u3, v0, v3));
                    verts.push(interpolate(u2, u1, v2, v1));
                    verts.push(interpolate(u2, u3, v2, v3));
                    faces.push([i, i + 1, i + 2]);
                    faces.push([i + 2, i + 1, i + 3]);
                } else {
                    let i = verts.len() as u32;
                    verts.push(interpolate(u0, u1, v0, v1));
                    verts.push(interpolate(u2, u1, v2, v1));
                    verts.push(interpolate(u3, u1, v3, v1));
                    faces.push([i, i + 1, i + 2]);
                }
            }
        } else {
            if u2 >= 0. {
                let u2 = u2 + tiny;
                if u3 >= 0. {
                    let i = verts.len() as u32;
                    verts.push(interpolate(u0, u2, v0, v2));
                    verts.push(interpolate(u0, u3, v0, v3));
                    verts.push(interpolate(u1, u2, v1, v2));
                    verts.push(interpolate(u1, u3, v1, v3));
                    faces.push([i, i + 1, i + 2]);
                    faces.push([i + 2, i + 1, i + 3]);
                } else {
                    let i = verts.len() as u32;
                    verts.push(interpolate(u0, u2, v0, v2));
                    verts.push(interpolate(u1, u2, v1, v2));
                    verts.push(interpolate(u3, u2, v3, v2));
                    faces.push([i, i + 1, i + 2]);
                }
            } else {
                if u3 >= 0. {
                    let i = verts.len() as u32;
                    verts.push(interpolate(u0, u3, v0, v3));
                    verts.push(interpolate(u1, u3, v1, v3));
                    verts.push(interpolate(u2, u3, v2, v3));
                    faces.push([i, i + 1, i + 2]);
                } else {
                }
            }
        }
    }
    // END GENERATED

}

/// Finds the isosurface of `u` at `level` using the marching tetrahedra algorithm.
///
/// Returns vertices, faces and normals.
pub fn marching_tetrahedra(u: &[f64],
                           dim: (usize, usize, usize),
                           level: f64)
                           -> (Vec<[f64; 3]>, Vec<[u32; 3]>, Vec<[f64; 3]>) {

    let (ni, nj, nk) = dim;
    assert_eq!(ni * nj * nk, u.len());

    let mut verts: Vec<[f64; 3]> = Vec::new();
    let mut faces: Vec<[u32; 3]> = Vec::new();

    let idx = [[(0, 0, 0), (1, 0, 0), (1, 1, 0), (1, 1, 1)],
               [(0, 0, 0), (1, 0, 0), (1, 0, 1), (1, 1, 1)],
               [(0, 0, 0), (0, 1, 0), (1, 1, 0), (1, 1, 1)],
               [(0, 0, 0), (0, 1, 0), (0, 1, 1), (1, 1, 1)],
               [(0, 0, 0), (0, 0, 1), (1, 0, 1), (1, 1, 1)],
               [(0, 0, 0), (0, 0, 1), (0, 1, 1), (1, 1, 1)]];

    for i in 1..ni {
        for j in 1..nj {
            for k in 1..nk {
                // split each cube into 6 tetrahedra, emit triangles
                let s = i * nj * nk + j * nk + k;
                let mut us = [0.; 4];
                let mut vs = [[0.; 3]; 4];

                for t in idx.iter() {
                    for m in 0..4 {
                        us[m] = u[s - t[m].0 * nj * nk - t[m].1 * nk - t[m].2];
                        vs[m] = [(i - t[m].0) as f64, (j - t[m].1) as f64, (k - t[m].2) as f64];
                    }

                    tetrahedron(us, vs, &mut verts, &mut faces);
                }
            }
        }
    }

    (verts, faces, Vec::new())
}

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {}
}
