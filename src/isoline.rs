
fn interpolate(a: f64, b: f64, v: [f64; 2], w: [f64; 2]) -> [f64; 2] {
    let x = a / (a - b);
    [(1. - x) * v[0] + x * w[0], (1. - x) * v[1] + x * w[1]]
}

/// Finds the intersection of a triangle with the zero level set of a linear function given by its
/// values on at the three verticel.
fn triangle(u: [f64; 3], v: [[f64; 2]; 3], verts: &mut Vec<[f64; 2]>) {
    // START GENERATED: generated by `scripts/triangle_cuts.py`
    let tiny = 1e-15;
    let u0 = u[0];
    let u1 = u[1];
    let u2 = u[2];
    let v0 = v[0];
    let v1 = v[1];
    let v2 = v[2];
    if u0 >= 0. {
        let u0 = u0 + tiny;
        if u1 >= 0. {
            let u1 = u1 + tiny;
            if u2 >= 0. {
            } else {
                verts.push(interpolate(u2, u0, v2, v0));
                verts.push(interpolate(u2, u1, v2, v1));
            }
        } else {
            if u2 >= 0. {
                verts.push(interpolate(u1, u0, v1, v0));
                verts.push(interpolate(u1, u2, v1, v2));
            } else {
                verts.push(interpolate(u1, u0, v1, v0));
                verts.push(interpolate(u2, u0, v2, v0));
            }
        }
    } else {
        if u1 >= 0. {
            let u1 = u1 + tiny;
            if u2 >= 0. {
                verts.push(interpolate(u0, u1, v0, v1));
                verts.push(interpolate(u0, u2, v0, v2));
            } else {
                verts.push(interpolate(u0, u1, v0, v1));
                verts.push(interpolate(u2, u1, v2, v1));
            }
        } else {
            if u2 >= 0. {
                verts.push(interpolate(u0, u2, v0, v2));
                verts.push(interpolate(u1, u2, v1, v2));
            } else {
            }
        }
    }
    // END GENERATED
}


/// Finds the isoline at `level` of a function given by its values `u` on a regular grid using a
/// marching triangles algorithm.
///
/// `dim` is the dimension of the array `u` assumed to be in _row-major order_ (C order).
///
/// Each square of the grid is split into two triangles, and the function is assumed to be  linear
/// on each triangle.
pub fn marching_triangles(u: &[f64], dim: (usize, usize), level: f64) -> Vec<[f64; 2]> {

    let (ni, nj) = dim;
    assert_eq!(ni * nj, u.len());

    let mut verts: Vec<[f64; 2]> = Vec::new();

    let (si, sj) = (nj, 1);

    for i in 1..ni {
        for j in 1..nj {
            let s = i * si + j * sj;

            let us = [u[s - si - sj] - level, u[s - sj] - level, u[s] - level];
            let vs = [[(i - 1) as f64, (j - 1) as f64],
                      [i as f64, (j - 1) as f64],
                      [i as f64, j as f64]];
            triangle(us, vs, &mut verts);

            let vs = [[(i - 1) as f64, (j - 1) as f64],
                      [(i - 1) as f64, j as f64],
                      [i as f64, j as f64]];
            let us = [u[s - si - sj] - level, u[s - si] - level, u[s] - level];
            triangle(us, vs, &mut verts);
        }
    }

    verts
}
